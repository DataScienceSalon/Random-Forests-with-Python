# Detroit Blight Ticket Data Initial Data Analysis 
*This is the first of a six-part series created to analyze and predict blight ticket compliance in the city of Detroit. You can find links to the other articles in this series at the bottom of the post.* 

The primary concern of the initial data analysis is data quality and engages questions such as:  
1. How should missing and faulty data be treated?    
2. What initial data transformations would be appropriate?  
3. What is the distribution and frequency characteristics of categorical variables?    
4. How should the data be prepared for exploratory data analysis and modeling?  

This article will examine the Detroit Blight Ticket Data in some detail and prescribe treatments and corrective actions which will be implemented in the following data preparation phase.

## Blight Ticket Data
The data for this project was made available courtesy of the publicly accessible Detroit Open Data Portal. Available blight ticket data has been split into a training set containing observations from 2005-2011 and a test set including blight tickets written between 2012 and 2016. Each row in these two files corresponds to a single blight ticket, and includes information about when, why, and to whom each ticket was issued. The target variable is compliance, which is True if the ticket was paid early, on time, or within one month of the hearing date, False if the ticket was paid after the hearing date or not at all, and Null if the violator was found not responsible. Compliance, as well as a handful of other variables that will not be available at test-time, are only included in train.csv. In addition, all tickets where the violators were determined to be "not responsible" are not considered during evaluation. They are included in the training set as an additional source of data for visualization, and to enable unsupervised and semi-supervised approaches. 

Two additional files, addresses.csv and latlons.csv have been provided for geolocation purposes. The former contains the violation addresses mapped to ticket_ids and the latter maps the addresses to latitude and longitude coordinates. 

* * *  

```{python libraries, code = readLines("../ida.py")[6:15]}
```
## Blight Ticket Data Overview
```{python ida_read, code = readLines("../ida.py")[20:33]}
```

The blight dataframe summarized in `r kfigr::figr(label = "format", prefix = TRUE, link = TRUE, type="Table")` contains `r nrow(py$df)` blight ticket observations and `r ncol(py$df)` variables.

```{python ida_info}
print(df.info())
```
`r kfigr::figr(label = "format", prefix = TRUE, link = TRUE, type="Figure")`: Blight Ticket Data Overview

Not every variable will be relevant to, or useful for, analysis and modeling. Let's trim the dataset down to the relevant observations and variables.

* * *  

## Data Selection
Here, we will identify the relevant observations and variables and eliminate the superfluous, redundant, and tangential data. Since our focus is blight ticket compliance, those observations with a "not responsible" determination can be removed. As indicated above, the variables containing payment and balance information are only included in the training set and can therefore be discarded. Redundant variables such as those containing fees, costs and discounts can also be eliminated from further analysis. 

```{python ida_select, code = readLines("../ida.py")[39:46]}
```

The trimmed dataframe described in `r kfigr::figr(label = "ida_vars", prefix = TRUE, link = TRUE, type="Figure")` now contains `r nrow(py$df)`  observations and `r ncol(py$df)` variables.  We can now proceed with the univariate data analysis. 

```{python ida_vars, echo=FALSE}
print(df.info())
```
`r kfigr::figr(label = "ida_vars", prefix = TRUE, link = TRUE, type="Figure")`: Selected Blight Ticket Data Variables

* * *  

## Univariate Analysis
Again, the univariate data analysis is primarily concerned with characterizing the quality of the data. The following descriptive statistics and frequency analyses will inform our downstream data processing, feature selection, feature engineering and modeling decisions. 

### Compliance  
```{python compliance, code = readLines("../ida.py")[53:59]}
```
Let's start with the target variable, Compliance. Por quÃ© no? 

As graphically depicted in `r kfigr::figr(label = "compliance_plot", prefix = TRUE, link = TRUE, type="Figure")`, the vast majority of blight tickets (`r round(py$compliance$Percent[2], 1)`%) were 'Non-Compliant' and there are no missing values.

```{python compliance_plot, code = readLines("../ida.py")[61:63]}
```
`r kfigr::figr(label = "compliance_plot", prefix = TRUE, link = TRUE, type="Figure")`: Compliance Summary

`r kfigr::figr(label = "compliance_tbl", prefix = TRUE, link = TRUE, type="Table")`: Compliance Distribution
```{r compliance_tbl}
knitr::kable(py$compliance, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

* * * 
### Agency
```{python agency, code = readLines("../ida.py")[70:73]}
```
`r kfigr::figr(label = "agency_plot", prefix = TRUE, link = TRUE, type="Figure")` shows `r sum(py$agency$Count)` blight tickets originating from one of the five enforcement agencies and there are no missing values for this variable.

```{python agency_plot, code = readLines("../ida.py")[75:78]}
```
`r kfigr::figr(label = "agency_plot", prefix = TRUE, link = TRUE, type="Figure")`: Blight Tickets by Agency

`r kfigr::figr(label = "agency_tbl", prefix = TRUE, link = TRUE, type="Table")`: Blight Tickets by Agency 
```{r agency_tbl}
knitr::kable(py$agency, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

As shown in `r kfigr::figr(label = "agency_tbl", prefix = TRUE, link = TRUE, type="Table")`, Neighborhood City Halls are responsible for just a single blight ticket. To ensure an adequate number of observations per categorical level, we'll combine the Neighhborhood City Halls and Detroit Police Department levels into a single categorical level.

* * *
### Inpector
```{python inspector, code = readLines("../ida.py")[85:94]}
```
`r kfigr::figr(label = "inspector_plot", prefix = TRUE, link = TRUE, type="Figure")` shows `r sum(py$inspector$Count)` blight tickets originating from one of the `r py$inspector_summary$unique` inspectors and there are no missing values for this variable.

`r kfigr::figr(label = "inspector_summary", prefix = TRUE, link = TRUE, type="Table")`: Blight Tickets by Inspector Summary
```{r inspector_summary}
knitr::kable(py$inspector_summary, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

```{python inspector_plot, code = readLines("../ida.py")[95:98]}
```
`r kfigr::figr(label = "inspector_plot", prefix = TRUE, link = TRUE, type="Figure")`: Inspector Blight Ticket Frequency Histogram

`r kfigr::figr(label = "inspector_spectrum", prefix = TRUE, link = TRUE, type="Table")`: Blight Tickets by Inspector Frequency Analysis
```{r inspector_spectrum}
knitr::kable(py$inspector_spectrum, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

As indicated in `r kfigr::figr(label = "inspector_plot", prefix = TRUE, link = TRUE, type="Figure")`, the distribution of blight ticket counts among the inspectors is significantly right-skewed. The median number of tickets is `r py$inspector_spectrum[1,6]`; whereas the mean is approximately `r round(py$inspector_spectrum[1,2], 0)` tickets, a differencing owing to outlier inspectors with upwards of  `r round(py$inspector_spectrum[1,8], 0)` blight tickets written as shown in `r kfigr::figr(label = "inspector_top10", prefix = TRUE, link = TRUE, type="Table")`.

`r kfigr::figr(label = "inspector_top10", prefix = TRUE, link = TRUE, type="Table")`: Top 10 Inspectors by Blight Tickets Written
```{r inspector_top10}
knitr::kable(as.data.frame(py$inspector_top10, row.names = NULL), digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```


No data quality issues appear extant; however, we may want to consider adding two new variables to capture the quantity and quality of tickets issued by an inspector. We could measure 'inspector productivity' as the number of prior tickets written and 'inspector effectivness' as the percentage of prior tickets written that were compliant. Let's put a pin in it for now and revisit this later at feature engineering time.

* * * 
### Violation Code
```{python violation, code = readLines("../ida.py")[104:113]}
```

`r kfigr::figr(label = "violation_summary", prefix = TRUE, link = TRUE, type="Table")` confirms that each of the `r py$violation_summary$observations` observations is written against one of `r py$violation_summary$unique` violation codes. There are no missing values.

`r kfigr::figr(label = "violation_summary", prefix = TRUE, link = TRUE, type="Table")`: Blight Tickets by Violation Code Summary
```{r violation_summary}
knitr::kable(py$violation_summary, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

```{python violation_plot, code = readLines("../ida.py")[115:117]}
```
`r kfigr::figr(label = "violation_plot", prefix = TRUE, link = TRUE, type="Figure")`: Blight Ticket by Violation Code Frequency Histogram

`r kfigr::figr(label = "violation_spectrum", prefix = TRUE, link = TRUE, type="Table")`: Blight Ticket by Violation Code Frequency Analysis
```{r violation_spectrum}
knitr::kable(py$violation_spectrum, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

Again, we have another significantly right-skewed frequency distribution.  Whereas half of the violation codes have `r py$violation_spectrum[1,6]` or fewer blight tickets, there are others with upwards of `r py$violation_spectrum[1,8]` tickets as shown in `r kfigr::figr(label = "violation_top10", prefix = TRUE, link = TRUE, type="Table")`.

`r kfigr::figr(label = "violation_top10", prefix = TRUE, link = TRUE, type="Table")`: Top 10 Violations by Blight Tickets Written
```{r violation_top10}
knitr::kable(py$violation_top10, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

There are no obvious data quality issues with this variable, and as with inspector, we may also consider the quantity of past tickets written against a violation code as well as the percentage of tickets that were compliant. Again, we'll take a note and re-address this at feature engineering time.

* * * 
### Violator 
```{python violator, code = readLines("../ida.py")[123:132]}
```

As indicated below, there are `r py$violator_summary$missing` values for the violator_name variable. Rather than removing these observations, we can impute the missing violation names with the violation street address.

`r kfigr::figr(label = "violator_summary", prefix = TRUE, link = TRUE, type="Table")`: Blight Tickets by Violator Summary
```{r violator_summary}
knitr::kable(py$violator_summary, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

```{python violator_plot, code = readLines("../ida.py")[134:136]}
```
`r kfigr::figr(label = "violator_plot", prefix = TRUE, link = TRUE, type="Figure")`: Blight Ticket by Violator Frequency Histogram

`r kfigr::figr(label = "violator_spectrum", prefix = TRUE, link = TRUE, type="Table")`: Blight Ticket by Violator Frequency Analysis
```{r violator_spectrum}
knitr::kable(py$violator_spectrum, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

As depicted in `r kfigr::figr(label = "violator_plot", prefix = TRUE, link = TRUE, type="Figure")` and in `r kfigr::figr(label = "violator_spectrum", prefix = TRUE, link = TRUE, type="Table")`, most violators have just a single violation; however, there are repeat offenders with upwards of `r py$violator_spectrum$max` violations.  The top 10 offenders are listed in `r kfigr::figr(label = "violator_top10", prefix = TRUE, link = TRUE, type="Table")`.

`r kfigr::figr(label = "violator_top10", prefix = TRUE, link = TRUE, type="Table")`: Top 10 Violations by Blight Tickets Written
```{r violator_top10}
knitr::kable(py$violator_top10, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

Again, we see no obvious data quality issues with this variable; as such, we may consider differentiating repeat offenders by assigning violators to one of several groups, based upon the number of offenses.

* * * 
### Violation Street
```{python violation_street, code = readLines("../ida.py")[142:151]}
```

Each of the `r py$violation_street_summary$observations` observations is written against a parcel on one of `r py$violation_street_summary$unique` streets in Detroit.  There are no missing values for this variable.

`r kfigr::figr(label = "violation_street_summary", prefix = TRUE, link = TRUE, type="Table")`: Blight Tickets by Street Summary
```{r violation_street_summary}
knitr::kable(py$violation_street_summary, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

```{python violation_street_plot, code = readLines("../ida.py")[153:155]}
```
`r kfigr::figr(label = "violation_street_plot", prefix = TRUE, link = TRUE, type="Figure")`: Blight Ticket by Street Frequency Histogram

`r kfigr::figr(label = "violation_street_spectrum", prefix = TRUE, link = TRUE, type="Table")`: Blight Ticket by Street Frequency Analysis
```{r violation_street_spectrum}
knitr::kable(py$violation_street_spectrum, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

As depicted in `r kfigr::figr(label = "violation_street_plot", prefix = TRUE, link = TRUE, type="Figure")` and in `r kfigr::figr(label = "violation_street_spectrum", prefix = TRUE, link = TRUE, type="Table")`, the median number of tickets per street is `r py$violation_street_spectrum[1,6]`; however, the mean is `r round(py$violation_street_spectrum[1,2],0)` tickets per street. This is owing to outlier streets which have upwards of `r py$violation_street_spectrum$max` blight tickets written. The 10 most frequently tickets streets are listed in `r kfigr::figr(label = "violation_street_top10", prefix = TRUE, link = TRUE, type="Table")`.

`r kfigr::figr(label = "violation_street_top10", prefix = TRUE, link = TRUE, type="Table")`: Top 10 Streets by Blight Tickets Written
```{r violation_street_top10}
knitr::kable(py$violation_street_top10, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

Once more, we should consider characterizing streets by the number of tickets written and the percentage of those tickets that were compliant.

* * * 

### City
```{python city, code = readLines("../ida.py")[161:170]}
```

The city variable corresponds with the mailing address of the violator, distinct from the violation address.  There is a city value for each of the `r py$city_summary$observations` observations. 

`r kfigr::figr(label = "city_summary", prefix = TRUE, link = TRUE, type="Table")`: Blight Tickets by Mailing City Summary
```{r city_summary}
knitr::kable(py$city_summary, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

```{python city_plot, code = readLines("../ida.py")[172:174]}
```
`r kfigr::figr(label = "city_plot", prefix = TRUE, link = TRUE, type="Figure")`: Blight Ticket by Mailing City Frequency Histogram

`r kfigr::figr(label = "city_spectrum", prefix = TRUE, link = TRUE, type="Table")`: Blight Ticket by Mailing City Frequency Analysis
```{r city_spectrum}
knitr::kable(py$city_spectrum, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

As depicted in `r kfigr::figr(label = "city_plot", prefix = TRUE, link = TRUE, type="Figure")` and in `r kfigr::figr(label = "city_spectrum", prefix = TRUE, link = TRUE, type="Table")`, the median number of tickets per street is `r py$city_spectrum[1,6]`; however, the mean is `r round(py$city_spectrum[1,2],0)` tickets per city. This is because nearly all violators live in Detroit.

`r kfigr::figr(label = "city_top10", prefix = TRUE, link = TRUE, type="Table")`: Top 10 Mailing Cities by Blight Tickets Written
```{r city_top10}
knitr::kable(py$city_top10, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

There are some data quality issues; however. Any analysis based upon city would require some cleaning and normalization of this field as evidenced by the various spellings and representations of the city of Detroit in `r kfigr::figr(label = "city_top10", prefix = TRUE, link = TRUE, type="Table")`.

* * * 
### State
```{python state, code = readLines("../ida.py")[181:190]}
```

`r kfigr::figr(label = "state_summary", prefix = TRUE, link = TRUE, type="Table")` indicates that there are `r py$state_summary$missing` missing values for state. This can be a consequence of having non-US violators or omission. We can adopt the following imputation strategy. If the country variable is US, we'll assume the state is Michigan.  For NON-US violators, we'll leave the value null as is.

`r kfigr::figr(label = "state_summary", prefix = TRUE, link = TRUE, type="Table")`: Blight Tickets by Mailing State Summary
```{r state_summary}
knitr::kable(py$state_summary, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

```{python state_plot, code = readLines("../ida.py")[192:194]}
```
`r kfigr::figr(label = "state_plot", prefix = TRUE, link = TRUE, type="Figure")`: Blight Ticket by Mailing State Frequency Histogram

`r kfigr::figr(label = "state_spectrum", prefix = TRUE, link = TRUE, type="Table")`: Blight Ticket by Mailing State Frequency Analysis
```{r state_spectrum}
knitr::kable(py$state_spectrum, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

As depicted in `r kfigr::figr(label = "state_plot", prefix = TRUE, link = TRUE, type="Figure")` and in `r kfigr::figr(label = "state_spectrum", prefix = TRUE, link = TRUE, type="Table")`, the median number of tickets per street is `r py$state_spectrum[1,6]`; however, the mean is `r round(py$state_spectrum[1,2],0)` tickets per state. This is because nearly all violators live in Detroit.

`r kfigr::figr(label = "state_top10", prefix = TRUE, link = TRUE, type="Table")`: Top 10 Mailing Cities by Blight Tickets Written
```{r state_top10}
knitr::kable(py$state_top10, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```


* * * 
### Zip Code
```{python zip_code, code = readLines("../ida.py")[200:209]}
```

The zip code variable pertains to the mailing address of the violator, and not the violation address. The training set, as indicated in `r kfigr::figr(label = "zip_code_summary", prefix = TRUE, link = TRUE, type="Table")`, has `r py$zip_code_summary$missing` missing value for zip_code. 

`r kfigr::figr(label = "zip_code_summary", prefix = TRUE, link = TRUE, type="Table")`: Blight Tickets by Zip Code Summary
```{r zip_code_summary}
knitr::kable(py$zip_code_summary, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

```{python zip_code_plot, code = readLines("../ida.py")[211:213]}
```
`r kfigr::figr(label = "zip_code_plot", prefix = TRUE, link = TRUE, type="Figure")`: Blight Ticket by Zip Code Frequency Histogram

`r kfigr::figr(label = "zip_code_spectrum", prefix = TRUE, link = TRUE, type="Table")`: Blight Ticket by Zip Code Frequency Analysis
```{r zip_code_spectrum}
knitr::kable(py$zip_code_spectrum, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

As depicted in `r kfigr::figr(label = "zip_code_plot", prefix = TRUE, link = TRUE, type="Figure")` and in `r kfigr::figr(label = "zip_code_spectrum", prefix = TRUE, link = TRUE, type="Table")`, the median number of tickets per zip code is `r py$zip_code_spectrum[1,6]`; however, the mean is `r round(py$zip_code_spectrum[1,2],0)` tickets per zip_code. Another right-skewed distribution with some zip codes having up to `r py$zip_code_spectrum$max` violations as revealed in `r kfigr::figr(label = "zip_code_top10", prefix = TRUE, link = TRUE, type="Table")`.

`r kfigr::figr(label = "zip_code_top10", prefix = TRUE, link = TRUE, type="Table")`: Top 10 Zip Codes by Blight Tickets Written
```{r zip_code_top10}
knitr::kable(py$zip_code_top10, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

Aside from the single missing value, there are no other data quality issues with this variable. That said, the zip code variable may be too granular to be useful as a predictor since it would require `r py$zip_code_summary$unique` categorical levels.  We may consider creating a new variable from the first three numbers of the zip code which pertains to regional areas.

* * * 
### Country
```{python country, code = readLines("../ida.py")[219:225]}
```
Blight violators hale from one of 5 countries; however nearly 100% are US based.

`r kfigr::figr(label = "country_tbl", prefix = TRUE, link = TRUE, type="Table")`: Blight Tickets by Country
```{r country_tbl}
knitr::kable(py$country, digits = 1) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

Given this inbalance, country would not be a useful categorical variable for analysis and prediction.

* * * 
### Latitude / Longitude
```{python lat_lon, code = readLines("../ida.py")[231:234]}
```

The following rather course summary of latitude and longtitude shows no glaring data quality problems aside from the two missing variables.

`r kfigr::figr(label = "ida_lat_lon", prefix = TRUE, link = TRUE, type="Table")`: Summary of Latitude and Longitude Variables
```{r ida_lat_lon}
knitr::kable(py$lat_lon, digits = 2) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

This data will be useful for a geolocation based visualization of the blight ticket data.

* * * 
### Dates
```{python dates, code = readLines("../ida.py")[241:252]}
```
Ticket issued dates appear to be in satisfactory condition. There are no missing dates and the date ranges are those that were expected.  However, two issues arise upon examination of the hearing dates. First, there are over 200 missing hearing dates and there are `r nrow(py$errors)` observations where the hearing date did not follow the date in which the ticket was issued. A sample of the potential errors are listed in `r kfigr::figr(label = "date_errors", prefix = TRUE, link = TRUE, type="Table")`.

`r kfigr::figr(label = "dates_summary", prefix = TRUE, link = TRUE, type="Table")`: Summary of Ticket Issued and Hearing Dates
```{r dates_summary}
knitr::kable(py$dates_summary, digits = 2) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

`r kfigr::figr(label = "date_errors", prefix = TRUE, link = TRUE, type="Table")`: Sampling of Date Errors
```{r date_errors}
knitr::kable(py$sample_errors, digits = 2) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

For both the missing and presumably incorrect hearing dates, the following imputation strategy could be adopted. Determine the mean interval between ticket issued date and hearing date for each violation code.  Add this mean interval for the violation code to the ticket issued date to arrive at a new hearing date for observations for which the hearing date is missing or presumed to be incorrect.

* * * 
### Judgment Amount
Alas, we come to the last variable for this univariate exploration. Judgment amounts covered a significant range from \$0 upwards to `r round(py$ja_distribution$max, 0)`\$. An inspection of the data revealed `r nrow(py$zero_ja)` observations with zero judgment amounts. All of these blight tickets were judged 'compliant by no fine'. 

```{python ja, code = readLines("../ida.py")[258:261]}
```


```{python ja_plot, code = readLines("../ida.py")[263:265]}
```
`r kfigr::figr(label = "ja_plot", prefix = TRUE, link = TRUE, type="Figure")`: Distribution of Judgment Amounts


`r kfigr::figr(label = "ja_summary", prefix = TRUE, link = TRUE, type="Table")`: Summary of Judgment Amounts
```{r ja_summary}
knitr::kable(py$ja_summary, digits = 2) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

`r kfigr::figr(label = "ja_distribution", prefix = TRUE, link = TRUE, type="Table")`: Distribution of Judgment Amounts
```{r ja_distribution}
knitr::kable(py$ja_distribution, digits = 2) %>%
  kableExtra::kable_styling(bootstrap_options = c("hover", "condensed", "responsive"), full_width = T, position = "center") 
```

As indicated in `r kfigr::figr(label = "ja_summary", prefix = TRUE, link = TRUE, type="Table")` and `r kfigr::figr(label = "ja_distribution", prefix = TRUE, link = TRUE, type="Table")`, both the mean and the mode judgment amount is `r round(ja_summary$top, 0)`\$. There were no obvious date quality issues with this variable.

* * * 


### Summary
1. Combine the agency variable categorical levels for Neighborhood City Halls and Detroit Police Department into a single categorical level.
2. Impute missing violator names with the street number and address of the violation.
3. Impute missing or incorrect hearing dates using the mean interval date for the violation code.

New Features   
As we noted above, there are two types of features to introduce: productivity and compliance levels.  The productivity level variable would be the number of past tickets written and the compliance level would be the percentage of past tickets written that were compliant.  We would create these two variables for each of the following variables:   
* Agency
* Inspector
* Violation Code
* Violator
* Violation Street

In addition, we may want to categorize the above by compliance levels. For instance, we may want to have an inspector productivity level variable with several levels based upon the percentage of compliant tickets written.

Create a region variable from the first three numbers of the zip code.